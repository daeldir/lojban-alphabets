/* Our translation functions share a "maps" object, that they can inspect to
 * find relation beetween different character sets. 
 *
 * For convenience, translation functions are in the "to" object, which is used
 * to automatically generate the user interface.
 */
var maps = {}, to = {};

/* Every other translation function depends on latin character set. Different
 * groups are defined for different usages.
 */
maps.latin = {
  letters:      "abcdefgijklmnoprstuvxyz.,' ",
  vowels:       "aeiouy",
  consonants:   "bcdfgjklmnprstvxz",
  punctuations: ".,' "
};

/* Conversion to latin alphabet does wipe unknown characters, and replace
 * numbers with their lojban name. An unknown character is "..", this a way to
 * say "something is missing here, look!".  All other translations depends on
 * this one, which is used to clean up the given text from any non-lojbanic
 * character.
 */
to.latin = function (text) {
  return text.replace(tests.each, function (match) {
    if (tests.isNumber(match)) return lojbanDigit(match);
    if (index(match, 'letters') == -1) return "..";
    return match
  });
};

/* The makeTest function is used to create a "test". A test is a function that
 * check if a string match the test. We have tests such as "isNumber",
 * "isUpperCase"... That are generated by this function.
 */
var makeTest = function (expression, flags) {
  return function (text) {
    return (new RegExp('^' + expression + '$', flags)).test(text);
  };
};

/* "tests" is an object containing some tests (really?). Those tests are either
 * functions, used to see if a text has some properties (as in
 * "isNumber(myText)"), or regular expressions, used in String#replace to work
 * on the characters of a text.
 *
 * We build the regular expressions from strings, and try to use meaningful
 * names to document how those regular expressions work.
 *
 * The "groups" test is a special one: it split a string in groups, used for
 * the tengwar mode - but I guess that those groups can be useful in other
 * phonetic alphabets, such as hangul. That test try to gather diphtongs (VV)
 * first, then "syllables" (CV). Then, it treats remaining letters alone
 * (remaining letters are either a consonant, a vowel, or a punctuation).
 */
var tests = (function () {
  var classes = {
    punctuation: '[' + maps.latin.punctuations + ']',
    consonant:   '[' + maps.latin.consonants   + ']',
    vowel:       '[' + maps.latin.vowels       + ']',
    upperCase:   '[A-Z]',
    number: '\\d',
    any: '.'
  };
  var conditions = {
    noVowelAfter: '(?!' + classes.vowel + ')',
    manyTimes: '+'
  };
  var groups = {
    diphtong: '(' + classes.vowel + classes.vowel + ')',
    syllable: '(' + classes.consonant + classes.vowel + 
                    conditions.noVowelAfter + ')'
  };
  var expressions = {
    groups: groups.diphtong  +'|' + groups.syllable + '|' + 
            classes.consonant + '|' + classes.vowel + '|' + 
            classes.punctuation,
    upperCase: classes.upperCase + conditions.manyTimes,
    atLeastOneUpperCase: classes.any + '*' + classes.upperCase + 
                         classes.any + '*'
  }
  return {
    isVowel:       makeTest(classes.vowel, 'i'),
    isPunctuation: makeTest(classes.punctuation, 'i'),
    isConsonant:   makeTest(classes.consonant, 'i'),
    isDiphtong:    makeTest(groups.diphtong, 'i'),
    isSyllable:    makeTest(groups.syllable, 'i'),
    isUpperCase:   makeTest(expressions.upperCase),
    hasUpperCase:  makeTest(expressions.atLeastOneUpperCase),
    isNumber:      makeTest(classes.number),
    groups:        new RegExp(expressions.groups, 'gi'),
    each:          new RegExp(classes.any, 'g')
  };
})();

/* Take a digit as argument, and return it's lojban name.
 */
var lojbanDigit = function (n) {
  return ['no', 'pa', 're', 'ci', 'vo', 'mu', 'xa', 'ze', 'bi', 'so'][n];
};

/* Look for the position of a character in one of the latin maps.
 *
 * This is used to easily get the index of a character in a map when dealing
 * with a latin text, and then use this index on an other alphabet map to get
 * the corresponding translated character.
 */
var index = function (character, map) {
  return maps.latin[map].indexOf(character.toLowerCase());
};

